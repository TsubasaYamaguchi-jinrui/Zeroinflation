[["index.html", "Zero-inflated model using R 本稿の目的", " Zero-inflated model using R Tsubasa Yamaguchi 2023-06-01 本稿の目的 本稿は主に一般化線形モデルで用いられることが多いゼロ過剰モデル(zero-inflated model)と呼ばれる手法の概要とRでの実装をまとめたものである。 本稿が主に参考にしたのは参考にしたのは Fox &amp; Sosa (2015) や 松浦 (2016) などである。 なお、本稿の作成に使用したファイルとRのコードは筆者のGithubですべて閲覧できる。 References Fox, G., &amp; Sosa, V. (2015). Mixture models for overdispersed data. In Ecological statictics: Contemporary theory and application (pp. 284–308). Oxford University Press. 松浦健太郎. (2016). StanとRでベイズ統計モデリング. 共立出版. "],["Chapter0.html", "0 パッケージの読み込み", " 0 パッケージの読み込み 本稿では、ゼロ過剰モデルの実行にglmmTMBパッケージを用いる。 また、モデルチェックや結果の図示にはeasystatsパッケージとDHARMaパッケージ、ggeffectsパッケージも用いている。 library(tidyverse) library(lme4) library(easystats) library(ggeffects) library(glmmTMB) library(statmod) library(DHARMa) library(brms) library(DT) なお、本稿はRの基本操作とtidyverseパッケージによるデータハンドリングができることを前提としている。tidyverseパッケージを用いたデータ処理については、以下の書籍などを参照。 R for Data Science (Wickham &amp; Grolemund, 2016) 電子書籍, 日本語 R Graphics Coocbook 2nd Edition (Chang, 2018) 電子書籍, 日本語 RユーザのためのRstudio[実践]入門~tidyverseによるモダンな分析フローの世界 改訂2版 (松村 et al., 2021) 出版社サイト References Chang, W. (2018). R graphics cookbook: Practical recipes for visualizing data. “O’Reilly Media, Inc.” Wickham, H., &amp; Grolemund, G. (2016). R for data science: Import, tidy, transform, visualize, and model data. “O’Reilly Media, Inc.” 松村優哉., 湯谷啓明., 紀ノ定保礼., &amp; 前田和. (2021). RユーザのためのRstudio[実践]入門 tidyverseによるモダンな分析フローの世界 改訂2版. 技術評論社. "],["Chapter1.html", "1 一般化線形モデル(GLM)における過分散 1.1 二項分布とポワソン分布の特徴 1.2 過分散とは", " 1 一般化線形モデル(GLM)における過分散 1.1 二項分布とポワソン分布の特徴 GLMでは、応答変数が二項分布やポワソン分布に従うと仮定してモデリングを行うことが多い。まずは、過分散について理解するためにこれらの分布の基本的な情報について確認する。 1.1.1 二項分布 二項分布は、「結果が2通り(例えば、成功/失敗)である試行（ベルヌーイ試行と呼ばれる）を独立に\\(n\\)回行ったときの成功回数の分布を表した確率分布」である。例えば、 コインを10回振ったときに表が出る回数は二項分布に従う。 一方の結果が生じる確率を\\(p\\)とするとき、\\(n\\)回中\\(x\\)回その結果が生じる確率\\(P(x|n,p)\\)は以下のように書ける(例. コインの表が出る確率が\\(p\\)のとき、\\(n\\)回中\\(x\\)回表が出る確率)。 \\[ P(x|n,p) = _n C _x p^x(1-p)^{n-x} \\quad (x \\geq 0) \\] 実際に表が出る確率が0.4のコインを10回ふったときの確率分布は以下のようになる。 ## xは0から10までとりうる x &lt;- seq(0,10,by=1) ## それぞれのxの値を取りうる確率 p_x &lt;- dbinom(x, size = 10, prob = 0.4) ## 作図 data.frame(x = x, p_x = p_x) %&gt;% ggplot(aes(x = x, y = p_x))+ geom_col()+ theme_bw(base_size = 12)+ theme(aspect.ratio = 1, axis.title.y = element_text(angle=0, vjust = 0.5))+ labs(y = &quot;x\\n回\\n表\\nが\\n出\\nる\\n確\\n率&quot;) 先ほどの式からわかるように、二項分布の形は\\(p\\)と\\(n\\)にという二つの値によって決まる。このように確率分布を特徴づける値のことを母数(パラメータ)という。GLMなどのモデリングでは、分布を決めるために必要なパラメータを実際のデータから推定することが目的になる。例えば、応答変数が二項分布に従うモデルを考える場合、試行数\\(n\\)は既知なので、データが得られる確率が最も高くなるように\\(p\\)を推定することがゴールとなる。 さて、二項分布の平均と分散は\\(p\\)と\\(n\\)によって以下のように定まる。ここで重要なのは、二項分布は\\(n\\)と\\(p\\)が定まれば平均も分散も決まってしまうということである。 平均: \\(np\\) 分散: \\(np(1-p)\\) 1.1.2 ポワソン分布 ポワソン分布は、「ある一定の時間にある事象が発生する回数(\\(x\\))を表す確率分布」である。たとえば、1年間に自動車事故が発生する回数はポワソン分布に従うとされます。二項分布と違い、ポワソン分布は回数に上限がないことに注意が必要(事故は何回でも起こりうる)。 ある事象が一定期間に起きる平均回数を\\(\\lambda\\)とするとき、その事象が\\(x\\)回生じる確率(\\(P(x)\\))は以下のようになる(覚える必要はないです)。 \\[ P(x) = \\frac{\\lambda^x}{x!}e^{-\\lambda} \\quad (x \\geq 0) \\] このように、ポワソン分布はたったひとつのパラメータ\\(\\lambda\\)によって形が決まる。ポワソン分布の平均と分散はいずれも\\(\\lambda\\)となる。 \\(\\lambda = 5.6\\)の時のポワソン分布は以下のようになる。 ## xは0から10までとりうる x &lt;- seq(0,15,by=1) ## それぞれのxの値を取りうる確率 p_x &lt;- dpois(x, 5.6) ## 作図 data.frame(x = x, p_x = p_x) %&gt;% ggplot(aes(x = x, y = p_x))+ geom_col()+ theme_bw(base_size = 12)+ theme(aspect.ratio = 1, axis.title.y = element_text(angle=0, vjust = 0.5))+ labs(y = &quot;x\\n回\\n事\\n象\\nが\\n生\\nじ\\nる\\n確\\n率&quot;) 1.2 過分散とは 以上で見たように、二項分布とポワソン分布では、いずれも分布の平均を決めるパラメータ(二項分布: \\(n\\)と\\(p\\)、ポワソン分布: \\(\\lambda\\))が決まれば分散も決まってしまう。 しかし実際にモデリングを行うとき、推定されたパラメータから期待されるよりも実際のデータの分散が大きくなってしまうことがよく生じる。このような現象を過分散という。 1.2.1 過分散の例 例えば、ニホンザルにある餌を10回提示したときに食べる回数を調べたとしよう。50個体分のデータを収集した結果、以下のデータが得られたとする(dat_binomというデータ)。なお、nは餌を提示した回数、xはサルが餌を食べた回数を示す。 シミュレーションによって架空のデータを作成する。 ## 架空データの作成 set.seed(123) N &lt;- 50 n &lt;- 10 age &lt;- rpois(N, lambda = 7) ## 平均して確率0.3で餌を食べるとするときの回数x。 r &lt;- rnorm(N, 0, 2.5) x &lt;- rep(0,N) p &lt;- rep(0,N) for(i in 1:50){ p[i] &lt;- inv_logit_scaled(-0.75 + 0.17*age[i]+ r[i]) x[i] &lt;- rbinom(1,n,p[i]) } dat_binom &lt;- data.frame(x = x, n = n) 生成されたデータがこちら。 dat_binom %&gt;% datatable() サルが餌を食べる確率\\(p\\)がどれくらいになるか調べるために、サルが餌を食べた回数が二項分布に従うと仮定してGLMによる分析を行うとする。なお、リンク関数はロジット関数とする。 数式で書くと以下のようになる。GLMでは、パラメータ\\(\\beta\\)を推定することになる。 \\[ \\begin{aligned} logit(p_i) &amp;= log(\\frac{p_i}{1-p_i}) = \\beta\\\\ x_i &amp;\\sim Binomial(n_i, p_i) \\end{aligned} \\] RでGLMを実行するコードは以下のようになる。 r_binom_sample &lt;- glm(data = dat_binom, cbind(x, n-x) ~ 1, family = &quot;binomial&quot;) 結果は以下のようになる。推定されたパラメータ\\(\\beta\\)は0.298である。 r_binom_sample ## ## Call: glm(formula = cbind(x, n - x) ~ 1, family = &quot;binomial&quot;, data = dat_binom) ## ## Coefficients: ## (Intercept) ## 0.2982 ## ## Degrees of Freedom: 49 Total (i.e. Null); 49 Residual ## Null Deviance: 313 ## Residual Deviance: 313 AIC: 397.7 このとき、分析結果から推定される\\(p\\)は、\\(log(\\frac{p}{1-p}) = e^{0.2982..}\\) より(リンク関数はロジット関数なので)、\\(p =\\) 0.574…となる。 これは実際のデータにおいてサルが餌を食べた平均割合ともほぼ一致する。 mean(dat_binom$x/dat_binom$n) ## [1] 0.574 もしデータが二項分布に従うならば、その分散は\\(np(1-p) = 10\\times0.574\\times0.426 = 2.445..\\)となるはずだと期待される。しかし、実際のデータの分散はそれよりも大きくなっている。 sd(dat_binom$x) ## [1] 3.498163 GLM(M)において、過分散が生じているかはdispersion parameter (\\(\\phi\\))が既定の値(ポワソン分布や二項分布では1)よりも大きいかで調べられる。 dispersion parameter (\\(\\phi\\))は以下の式で算出される。 なお、\\(y_i\\)は応答変数の値、\\(\\mu_i\\)はモデルから推定されたi番目の期待値(平均値)、\\(\\sigma_i\\)はモデルから推定されたi番目の分散を表す。また、残差自由度は全自由度(データ数)からモデルで推定されたパラメータ数(今回は\\(\\lambda\\)の1つ)を引いたものである(つまり、今回は199)。 \\[ \\begin{aligned} \\phi &amp;= \\frac{ピアソン残差^2}{残差自由度}\\\\ &amp;= \\frac{y_i-\\mu_i/ \\sigma_i}{残差自由度} \\end{aligned} \\] Rでは以下のように求められる。 値が1を大きく超えており、過分散が生じていることが分かる。 sum(residuals(r_binom_sample,type = &quot;pearson&quot;)^2)/r_binom_sample$df.residual ## [1] 5.004475 また、過分散が生じているかは、推定したパラメータを持つ分布からデータをシミュレートし、それを実際のデータと比較することで検定することもできる。詳しい方法については、このサイトを参照。 検定の結果、有意な過分散が検出された。 testDispersion(r_binom_sample) ## ## DHARMa nonparametric dispersion test via sd of residuals fitted vs. ## simulated ## ## data: simulationOutput ## dispersion = 5.0808, p-value &lt; 2.2e-16 ## alternative hypothesis: two.sided このようなとき、このモデルには過分散が生じているという。 1.2.2 過分散の問題点 過分散が生じているということは、推定値のばらつきが過小評価されており、データがモデルにうまく適合していないことを示す(Fox &amp; Sosa, 2015; Harrison et al., 2018)。 これによって生じる大きな問題は、統計検定において第一種の過誤(帰無仮説が正しいにもかかわらず誤って棄却してしまうこと)が生じる確率が高まってしまうということである(Fox &amp; Sosa, 2015; Harrison et al., 2018) 1.2.3 過分散が生じる要因とゼロ過剰 過分散が生じる要因としては、空間的・時間的相関があることでデータに偏りが生じること、データが独立でないこと(cf. 疑似反復)、データ間のばらつきが大きいことなどがある。こうした要因によって過分散が生じている際の一般的な解決策としては、疑似尤度を用いる、ランダム効果を用いるなどの方法がある(粕谷, 2012)。 本稿で着目するのは、これら以外の要因、すなわちモデルから想定されるよりもゼロが多くなってしまう場合(ゼロ過剰)についてである。以下ではゼロ過剰が生じているデータについて見たうえで、その対処法についてまとめる。こうしたデータに対しては、ゼロ過剰モデルを用いることで対処することができる。 References Fox, G., &amp; Sosa, V. (2015). Mixture models for overdispersed data. In Ecological statictics: Contemporary theory and application (pp. 284–308). Oxford University Press. Harrison, X. A., Donaldson, L., Correa-Cano, M. E., Evans, J., Fisher, D. N., Goodwin, C. E. D., Robinson, B. S., Hodgson, D. J., &amp; Inger, R. (2018). A brief introduction to mixed effects modelling and multi-model inference in ecology. PeerJ, 2018(5). 粕谷英一. (2012). 一般化線形モデル. 共立出版. "],["Chapter2.html", "2 ゼロ過剰ポワソンモデルとは 2.1 ポワソン回帰でゼロ過剰が生じる例 2.2 対処法: ゼロ過剰ポワソンモデル 2.3 ゼロ過剰ポワソンモデルの分析例", " 2 ゼロ過剰ポワソンモデルとは 以下では、応答変数がポワソン分布に従うと仮定したときにゼロ過剰が生じる場合について見ていく。 2.1 ポワソン回帰でゼロ過剰が生じる例 例えば、森の中である一定距離歩いたときに見つかるニホンザルの数のデータを収集したところ、以下のデータ(d_zipois)が得られたとする。なお、num_obsは観察したサルの数を、tempはその日の気温を表す。 シミュレーションによって架空のデータを作成する。 ## データの作成 set.seed(1234) N &lt;- 200 temp &lt;- rnorm(N, 10, 1.5) p_zi &lt;- exp((7 - 0.8*temp))/(1 + exp((7 - 0.8*temp))) num_obs &lt;- rep(0,N) for(i in 1:N){ num_obs[i] &lt;- rbinom(1,1,1-p_zi[i])*rpois(1, lambda = exp(0.02 + 0.13*temp[i])) } dat_zipois &lt;- data.frame(temp = temp, num_obs = num_obs) 作成されたデータがこちら。 dat_zipois 気温と観察されたサルの数の関係を調べたところ、以下のようになった。気温が高くなるほど、観察されるサルの数が多くなるように見える。 dat_zipois %&gt;% ggplot(aes(x = temp, y = num_obs))+ geom_point(size = 3.5, alpha = 0.6)+ theme_bw(base_size = 12)+ theme(aspect.ratio=0.8) そこで、以下のようなGLMを考え、気温が観察されるサルの数に与える影響を調べるとする。 分布: ポワソン分布 リンク関数: log関数 応答変数: 観察されたサルの数(num_obs) 説明変数: 気温(temp) 数式で表すと以下のようになる。ただし、\\(i\\)は各データポイントのIDを示す。例えば、\\(temp_i\\)は、\\(i\\)番目のデータの気温を表す。ただし、\\(i = 1,2,3,...,200\\)である。また、\\(num\\_obs_i \\sim Poisson(\\lambda_i)\\)は、i番目のデータが平均\\(\\lambda_i\\)のポワソン分布に従って得られるということである。 \\[ \\begin{aligned} log(\\lambda_i) &amp;= \\beta_0 + \\beta_1 \\times temp_i\\\\ num\\_obs_i &amp;\\sim Poisson(\\lambda_i) \\end{aligned} \\] RでのGLMのコードは以下のようになる。 r_pois &lt;- glm(data = dat_zipois, num_obs ~ temp, family = poisson(link=log)) 結果は以下のようになり、\\(\\beta_0\\)の推定値は-2.385、\\(\\beta_1\\)の推定値は0.328である。 summary(r_pois) ## ## Call: ## glm(formula = num_obs ~ temp, family = poisson(link = log), data = dat_zipois) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -3.6916 -1.7871 -0.3212 0.9002 3.3833 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -2.3854 0.2855 -8.355 &lt;2e-16 *** ## temp 0.3284 0.0263 12.490 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for poisson family taken to be 1) ## ## Null deviance: 660.31 on 199 degrees of freedom ## Residual deviance: 510.09 on 198 degrees of freedom ## AIC: 914.02 ## ## Number of Fisher Scoring iterations: 5 つまり、観察されるサルの数は\\(\\lambda = e^{-2.385 + 0.328 \\times temp_i}\\)を平均とするポワソン分布から得られると推定された。 そこで、推定したパラメータを持つモデルの下で得られるデータをシミュレートし(num_obs_sim)、それを実際に得られたデータと比較してみる。 下の図からわかるように、実際に得られたデータ(num_obs)では、推定されたモデルからシミュレートされたデータ(num_obs_sim)よりかなり0が多いことが分かる。このようなとき、ゼロ過剰が生じているという。 ## モデルの下で得られるデータをシミュレート num_obs_sim &lt;- rpois(N, lambda = exp(coef(r_pois)[[1]])+coef(r_pois)[[2]]*dat_zipois$temp) ## 実際のデータと比較 data.frame(num_obs = num_obs, num_obs_sim = num_obs_sim) %&gt;% pivot_longer(cols = 1:2) %&gt;% ggplot(aes(x = value))+ geom_histogram(aes(fill = name), position = &quot;dodge&quot;, alpha = 0.8, breaks = seq(0,15,1))+ theme_bw(base_size = 13)+ theme(aspect.ratio=0.8, axis.title.y = element_text(angle=0,vjust=0.5))+ labs(x = &quot;サルが観察された回数&quot;, y = &quot;度\\n数&quot;) -&gt; p_pois_hist p_pois_hist 実際のデータに含まれる0の数と、モデルが正しいと仮定したときにシミュレーションで生成したデータに含まれる0の数を比較することで、ゼロ過剰が生じているかを検定することができる(詳細はこちら)。検定の結果、ゼロ過剰が検出された。 testZeroInflation(r_pois) ## ## DHARMa zero-inflation test via comparison to expected zeros with ## simulation under H0 = fitted model ## ## data: simulationOutput ## ratioObsSim = 3.069, p-value &lt; 2.2e-16 ## alternative hypothesis: two.sided Dispersion parameterを算出すると値が1を大きく超えており、過分散が生じていることが分かる。ゼロ過剰であることが原因だろう。 sum(residuals(r_pois,type = &quot;pearson&quot;)^2)/r_pois$df.residual ## [1] 2.233114 過分散の検定をしても過分散が検出される。 resid_pois &lt;-simulateResiduals(r_pois) testDispersion(resid_pois) ## ## DHARMa nonparametric dispersion test via sd of residuals fitted vs. ## simulated ## ## data: simulationOutput ## dispersion = 2.0984, p-value &lt; 2.2e-16 ## alternative hypothesis: two.sided Quantile residual(詳細はこちら)についてQQplotを描画しても、データがモデルで仮定された分布と合致していないことが分かる。 plotQQunif(resid_pois) このモデルの推定結果に基づく回帰曲線は以下のようになる。 fit_pois &lt;- ggpredict(r_pois, ## 温度は5~15で0.1刻み terms = &quot;temp[5:15,by=0.1]&quot;, ## ここを変える type =&quot;fixed&quot;) ggplot(dat_zipois)+ geom_point(aes(x = temp, y = num_obs), size = 3.5, alpha = 0.6)+ ### 回帰曲線 geom_line(data = fit_pois, aes(x=x, y = predicted))+ ## 95%信頼区間 geom_ribbon(data = fit_pois, aes(x=x, y = predicted, ymin = conf.low, ymax = conf.high), alpha = 0.5)+ theme_bw(base_size = 18)+ theme(aspect.ratio=0.8, plot.title = (element_text(size = 17)))+ labs(title = &quot;普通のポワソン回帰&quot;)-&gt; p_pois p_pois 2.2 対処法: ゼロ過剰ポワソンモデル こうしたゼロ過剰のデータに対する対処法の1つがゼロ過剰を仮定したモデル(ゼロ過剰ポワソンモデル)を用いることである。ゼロ過剰ポワソンモデルでは、以下のような2段階の過程で\\(i\\)番目のデータ(\\(y_i\\))が得られると仮定する。 ➀ 確率\\(q_i\\)でデータが必ず0になる。 ➁ \\(1-q_i\\)の確率で、データ\\(y_i\\)が平均\\(\\lambda_i\\)のポワソン分布にしたがって得られる。 つまり、ゼロ過剰モデルは2種類のプロセスから得られた0が存在することを仮定する。すなわち、ある確率\\(q_i\\)で必ず0が得られるとき(1)と、\\(1-q_i\\)の確率でデータがポワソン分布に従う場合に0が得られるとき(2)である。 図2.1: ゼロ過剰ポワソンモデルでデータが得られる過程 このようなプロセスで得られていると考えられるデータとしては、以下のような例が挙げられる。 例1. 各選手の盗塁成功数 盗塁数が0の選手の中には、そもそも盗塁しようとしない人と、盗塁しようとした結果失敗した人が含まれる。 例2. 動物のセンサスデータ 0のデータの中には、本当にセンサス中にその動物がいなかった場合と、動物がいたにもかかわらず観察者が何らかの要因(人間の観察能力の限界や観察環境など)によって見つけられなかった場合が含まれる。 以下にそのような場合が考えられる例を挙げる。 ゼロ過剰ポワソンモデルにおいて、0が得られる確率は以下のようになる(1.2.2も参照)。 \\[ q_i + (1-q_i)\\times\\frac{\\lambda_i^0}{0!} e^{-\\lambda_i} \\\\ = q_i + (1-q_i)\\times e^{-\\lambda_i} \\] 0以外の値\\(y\\)が得られる確率は以下のようになる。 \\[ (1-q_i)\\times \\frac{\\lambda^y}{y!}e^{-\\lambda} \\;\\; (ただし、y&gt;0) \\] 2.3 ゼロ過剰ポワソンモデルの分析例 それでは、先ほどのデータをゼロ過剰ポワソンモデルに当てはめよう。データが以下の式に従って得られると仮定する。このモデルでは、\\(q_i\\)も気温によって変化すると仮定する(気温によらないとモデリングすることもできる)。なお、\\(num\\_obs_i \\sim ZIPoisson(\\lambda_i)\\)はサルの観察回数がゼロ過剰ポワソンモデルに従って得られることを示す。 \\[ \\begin{aligned} logit(q_i) &amp;= log(\\frac{q_i}{1-q_i}) = \\beta_{10} + \\beta_{11} \\times temp_i\\\\ log(\\lambda_i) &amp;= \\beta_{20} + \\beta_{21}\\times temp_i\\\\ num\\_obs_i &amp;\\sim ZIPoisson(q_i, \\lambda_i) \\end{aligned} \\] RではglmmTMBパッケージを用いて以下のようにパラメータを推定できる。\\(q_i\\)が気温によらないと仮定する場合は、ziformula ~ 1とする。 r_zipois &lt;- glmmTMB(data = dat_zipois, num_obs ~ temp, ## 気温によらない場合は ziformula ~ 1 ziformula = ~temp, family = &quot;poisson&quot;) モデルで推定されたパラメータは以下のようになる。 Zero-inflation model:というところにある推定結果が\\(q_i\\)に関するパラメータの推定値であり、\\(\\beta_{10}\\)と\\(\\beta_{11}\\)の推定値はそれぞれ7.257、-0.805となる。 Conditional model:というところにある推定結果が\\(\\lambda_i\\)に関するパラメータの推定値であり、\\(\\beta_{20}\\)と\\(\\beta_{21}\\)の推定値はそれぞれ-0.086、0.146となる。 summary(r_zipois) ## Family: poisson ( log ) ## Formula: num_obs ~ temp ## Zero inflation: ~temp ## Data: dat_zipois ## ## AIC BIC logLik deviance df.resid ## 740.4 753.6 -366.2 732.4 196 ## ## ## Conditional model: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -0.08594 0.32828 -0.262 0.793 ## temp 0.14628 0.03014 4.854 1.21e-06 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Zero-inflation model: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 7.2573 1.4502 5.004 5.61e-07 *** ## temp -0.8045 0.1510 -5.328 9.94e-08 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 推定したパラメータを持つゼロ過剰ポワソンモデルの下で得られるデータをシミュレートし(num_obs_zisim)、それを実際に得られたデータと比較してみる。 ## 推定されたパラメータからデータをシミュレート q &lt;- 1/(1 +exp(-(fixef(r_zipois)[[2]][[1]] + fixef(r_zipois)[[2]][[2]]*dat_zipois$temp))) lambda &lt;- exp((fixef(r_zipois)[[1]][[1]] + fixef(r_zipois)[[1]][[2]]*dat_zipois$temp)) num_obs_zisim &lt;- rbinom(N,1,1-q)*rpois(N, lambda) 下の図からわかるように、推定されたモデルからシミュレートされたデータ(num_obs_zisim)の分布は、実際のデータとかなりよくマッチしていることが分かる。 ## 実際のデータと比較 data.frame(num_obs = dat_zipois$num_obs, num_obs_zisim = num_obs_zisim) %&gt;% pivot_longer(cols = 1:2) %&gt;% ggplot(aes(x = value))+ geom_histogram(aes(fill = name), position = &quot;dodge&quot;, alpha = 0.8, breaks = seq(0,15,1))+ theme_bw(base_size = 13)+ theme(aspect.ratio=0.8, axis.title.y = element_text(angle=0,vjust=0.5))+ labs(x = &quot;サルが観察された回数&quot;, y = &quot;度\\n数&quot;) -&gt; p_zipois_hist p_zipois_hist これは、普通のポワソンモデルの結果と比較すると明白である。なお、num_obs_simは普通のポワソン分布を仮定したGLMで推定されたパラメータからシミュレートされたデータである。 data.frame(num_obs = num_obs, num_obs_zisim = num_obs_zisim, num_obs_sim = num_obs_sim) %&gt;% pivot_longer(cols = 1:3) %&gt;% mutate(name = fct_relevel(name,&quot;num_obs&quot;,&quot;num_obs_zisim&quot;)) %&gt;% ggplot(aes(x = value))+ geom_histogram(aes(fill = name), position = &quot;dodge&quot;, alpha = 0.8, breaks = seq(0,15,1))+ theme_bw(base_size = 13)+ theme(aspect.ratio=0.8, axis.title.y = element_text(angle=0,vjust=0.5))+ labs(x = &quot;サルが観察された回数&quot;, y = &quot;度\\n数&quot;) 検定をしても、ゼロ過剰は検出されない。 testZeroInflation(r_zipois) ## ## DHARMa zero-inflation test via comparison to expected zeros with ## simulation under H0 = fitted model ## ## data: simulationOutput ## ratioObsSim = 0.99404, p-value = 1 ## alternative hypothesis: two.sided 過分散も解消されたことが分かる。 resid_zipois &lt;-simulateResiduals(r_zipois) testDispersion(resid_zipois) ## ## DHARMa nonparametric dispersion test via sd of residuals fitted vs. ## simulated ## ## data: simulationOutput ## dispersion = 1.0069, p-value = 0.904 ## alternative hypothesis: two.sided QQplotをみても、データがモデルが仮定する分布によく合致している。 plotQQunif(resid_zipois) 推定されたモデルに基づく回帰曲線を描画する。 確率\\(q_i\\)で得られた0を含まないものと、含むものを両方描ける。詳細はこちら。 \\(q_i\\)で得られた0を含まない場合 fit_zipois_a &lt;- ggpredict(r_zipois, ## 温度は5~15で0.1刻み terms = &quot;temp[5:15,by=0.1]&quot;, type =&quot;fixed&quot;) ggplot(dat_zipois)+ geom_point(aes(x = temp, y = num_obs), size = 3.5, alpha = 0.6)+ ### 回帰曲線 geom_line(data = fit_zipois_a, aes(x=x, y = predicted))+ ## 95%信頼区間 geom_ribbon(data = fit_zipois_a, aes(x=x, y = predicted, ymin = conf.low, ymax = conf.high), alpha = 0.5)+ theme_bw(base_size = 18)+ theme(aspect.ratio=0.8, plot.title=element_text(size = 17))+ labs(title = &quot;ゼロ過剰ポワソンモデル\\n(qによる0含まず)&quot;)-&gt; p_zipois_a \\(q_i\\)で得られた0を含む場合 fit_zipois_b &lt;- ggpredict(r_zipois, ## 温度は5~15で0.1刻み terms = &quot;temp[5:15,by=0.1]&quot;, ## ここを変える type =&quot;zero_inflated&quot;) ggplot(dat_zipois)+ geom_point(aes(x = temp, y = num_obs), size = 3.5, alpha = 0.6)+ ### 回帰曲線 geom_line(data = fit_zipois_b, aes(x=x, y = predicted))+ ## 95%信頼区間 geom_ribbon(data = fit_zipois_b, aes(x=x, y = predicted, ymin = conf.low, ymax = conf.high), alpha = 0.5)+ theme_bw(base_size = 18)+ theme(aspect.ratio=0.8, plot.title=element_text(size = 17))+ labs(title = &quot;ゼロ過剰ポワソンモデル\\n(qによる0含む)&quot;) -&gt; p_zipois_b 比較のため、普通のポワソン回帰による回帰曲線も併置する。 library(patchwork) p_pois + p_zipois_a + p_zipois_b + plot_layout(ncol = 2) "],["Chapter3.html", "3 ゼロ過剰二項モデルとは 3.1 ロジスティック回帰でゼロ過剰が生じる例 3.2 対処法: ゼロ過剰二項モデル 3.3 ゼロ過剰二項モデルの分析例1(GLMの場合) 3.4 ゼロ過剰二項モデルの分析例2(GLMMの場合)", " 3 ゼロ過剰二項モデルとは 以下では、同様に応答変数が二項分布に従うと仮定したときにゼロ過剰が生じる場合について見ていく。 3.1 ロジスティック回帰でゼロ過剰が生じる例 ニホンザルのメスが群れ外オスから攻撃された直後に怪我が確認されるか否かを調べた結果、以下のデータ(dat_zibinom)が得られたとする。なお、sumは攻撃された回数を、num_injは攻撃の直後に怪我が確認された回数を、ageはメスの年齢を表す。 シミュレーションによって架空のデータを作成する。 set.seed(1234) N &lt;- 200 age &lt;- rnorm(N, 15, 3.5) sum &lt;- rpois(N,100) p &lt;- exp((0.8 - 0.08*age))/(1 + exp((0.8 - 0.08*age))) num_inj &lt;- rep(0,N) for(i in 1:N){ num_inj[i] &lt;- rbinom(1,1,1-p[i])*rbinom(1, sum[i], exp(-5.5 + 0.12*age[i])/(1 + exp(-5.5 + 0.12*age[i]))) } dat_zibinom &lt;- data.frame(age = age, num_inj = num_inj, sum = sum) 作成されたデータがこちら。 dat_zibinom %&gt;% datatable() サルの年齢(age)と攻撃の直後に怪我が確認された割合(num_inj/sum)をプロットしたところ、以下のようになった。年齢が高くなるほど、怪我が確認された割合が多くなるように見える。 dat_zibinom %&gt;% ggplot(aes(x = age, y = num_inj/sum))+ geom_point(size = 3.5, alpha = 0.6)+ theme_bw(base_size = 12)+ theme(aspect.ratio= 0.8, axis.title.y = element_text(angle=0, vjust=0.5, size = 10))+ coord_cartesian(ylim = c(0,0.122))+ scale_y_continuous(breaks = seq(0,0.15,0.02))+ labs(y = &quot;怪\\n我\\nが\\n確\\n認\\nさ\\nれ\\nた\\n割\\n合&quot;) そこで、以下のようなGLMを考え、年齢が怪我が確認された割合に影響するかを調べる。 分布: 二項分布 リンク関数: logit関数 応答変数: 怪我が確認された割合(num_inj/sum) 説明変数: 年齢(age) 数式で表すと以下のようになる。ただし、\\(i\\)は各データポイントのIDを示す。例えば、\\(age_i\\)は、\\(i\\)番目の個体の年齢を表す。ただし、\\(i = 1,2,3,...,200\\)である。 なお、\\(num\\_inj_i \\sim Binomial(sum_i,p_i)\\)は、i番目の個体に怪我が確認された回数が試行数\\(sum_i\\)、確率(\\(p_i\\))の二項分布に従って得られるということを示す。 \\[ \\begin{aligned} logit(p_i) &amp;= log(\\frac{p_i}{1-p_i}) = \\beta_0 + \\beta_{2} \\times age_i\\\\ num\\_inj_i &amp;\\sim Binomial(trials_i, p_i) \\end{aligned} \\] RでのGLMのコードは以下のようになる。 r_binom &lt;- glm(data = dat_zibinom, cbind(num_inj, sum-num_inj) ~ age, family = binomial(link=logit)) 結果は以下のようになり、\\(\\beta_0\\)の推定値は-6.045、\\(\\beta_1\\)の推定値は0.128である。 summary(r_binom) ## ## Call: ## glm(formula = cbind(num_inj, sum - num_inj) ~ age, family = binomial(link = logit), ## data = dat_zibinom) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -3.2819 -1.5432 -0.3570 0.9607 3.9672 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -6.04528 0.24236 -24.944 &lt;2e-16 *** ## age 0.12802 0.01432 8.938 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for binomial family taken to be 1) ## ## Null deviance: 495.59 on 199 degrees of freedom ## Residual deviance: 418.10 on 198 degrees of freedom ## AIC: 746.05 ## ## Number of Fisher Scoring iterations: 5 つまり、怪我が確認される回数は試行数\\(sum_i\\)、\\(p_i = \\frac{1}{1 + -e^{-6,045 + 0.128 \\times age_i}}\\)となる二項分布から得られると推定される(\\(log(\\frac{p_i}{1-p_i}) = \\beta_0 + \\beta_{2} \\times age_i\\)より)。 そこで、推定したパラメータを持つモデルの下で得られるデータをシミュレートし(num_inj_sim)、それを実際に得られたデータと比較してみる。 下の図からわかるように、実際に得られたデータから算出された怪我が観察された割合(prop_inj)では、推定されたモデルからシミュレートされたデータ(prop_inj_sim)より0が多い(= ゼロ過剰が生じている)。怪我がをしていても体毛に隠れていて気づかない場合があったなど、0が増えてしまう何らかのメカニズムがあったと推測される。 ## モデルの下で得られるデータをシミュレート p &lt;- 1/(1 +exp(-(coef(r_binom)[[1]] + coef(r_binom)[[2]]*dat_zibinom$age))) num_inj_sim &lt;- rbinom(N, dat_zibinom$sum, p) prop_inj_sim &lt;- num_inj_sim/dat_zibinom$sum ## 実際のデータと比較 data.frame(prop_inj = num_inj/dat_zibinom$sum, prop_inj_sim = prop_inj_sim) %&gt;% pivot_longer(cols = 1:2) %&gt;% ggplot(aes(x = value))+ geom_histogram(aes(fill = name), position = &quot;dodge&quot;, alpha = 0.8, breaks = seq(0,0.2,by=0.01))+ theme_bw(base_size = 13)+ theme(aspect.ratio=0.8, axis.title.y = element_text(angle=0,vjust=0.5))+ labs(x = &quot;怪我が確認された割合&quot;, y = &quot;度\\n数&quot;)+ coord_cartesian(xlim = c(0,0.13))-&gt; p_binom_hist p_binom_hist 検定をすると、ゼロ過剰が検出される。 testZeroInflation(r_binom) ## ## DHARMa zero-inflation test via comparison to expected zeros with ## simulation under H0 = fitted model ## ## data: simulationOutput ## ratioObsSim = 1.8522, p-value &lt; 2.2e-16 ## alternative hypothesis: two.sided dispersion parameterを算出すると、二項分布での規定値(= 1)を越えており、過分散が生じていることが分かる。おそらくゼロ過剰が原因だろう。 sum(residuals(r_binom,type = &quot;pearson&quot;)^2)/r_binom$df.residual ## [1] 1.806725 検定を行っても過分散が検出された。 resid_binom &lt;-simulateResiduals(r_binom) testDispersion(resid_binom) ## ## DHARMa nonparametric dispersion test via sd of residuals fitted vs. ## simulated ## ## data: simulationOutput ## dispersion = 1.6742, p-value &lt; 2.2e-16 ## alternative hypothesis: two.sided QQplotをみても、データがモデルによく当てはまっていないことが分かる。 plotQQunif(resid_binom) このモデルの推定結果に基づく回帰曲線は以下のようになる。 fit_binom &lt;- ggpredict(r_binom, ## 温度は5~15で0.1刻み terms = &quot;age[5:26,by=0.1]&quot;, ## ここを変える type =&quot;fixed&quot;) ggplot(dat_zibinom)+ geom_point(aes(x = age, y = num_inj/sum), size = 3.5, alpha = 0.6)+ ### 回帰曲線 geom_line(data = fit_binom, aes(x=x, y = predicted))+ ## 95%信頼区間 geom_ribbon(data = fit_binom, aes(x=x, y = predicted, ymin = conf.low, ymax = conf.high), alpha = 0.5)+ theme_bw(base_size = 18)+ theme(aspect.ratio= 0.8, axis.title.y = element_text(angle=0, vjust=0.5, size =10), plot.title=element_text(size = 17))+ coord_cartesian(ylim = c(0,0.122))+ scale_y_continuous(breaks = seq(0,0.15,0.02))+ labs(title = &quot;普通の二項分布モデル&quot;, y = &quot;怪\\n我\\nが\\n確\\n認\\nさ\\nれ\\nた\\n割\\n合&quot;)-&gt; p_binom p_binom 3.2 対処法: ゼロ過剰二項モデル こうしたゼロ過剰のデータに対する対処法の1つが、ポワソン分布の場合と同様に、ゼロ過剰を仮定したモデル(ゼロ過剰二項モデル)を用いることである。ゼロ過剰二項モデルでも、ゼロ過剰ポワソンモデルのように2段階の過程で\\(i\\)番目のデータ(\\(y_i\\))が得られると仮定する。 ➀ 確率\\(q_i\\)でデータが必ず0になる。 ➁ \\(1-q_i\\)の確率で、データ\\(y_i\\)が確率\\(p_i\\)、試行数\\(n_i\\)の二項分布に従って得られる。 すなわち、ゼロ過剰モデルは2種類のプロセスから得られた0が存在することを仮定する。すなわち、ある確率\\(q_i\\)で必ず0が得られるとき(1)と、\\(1-q_i\\)の確率でデータが二項分布に従う場合に0が得られるとき(2)である。 図3.1: ゼロ過剰二項モデルでデータが得られる過程 ゼロ過剰二項分布において、0が得られる確率は以下のようになる。 \\[ q_i + (1-q_i)\\times _n C _0 p_i^0(1-p_i)^{n_i-0} \\\\ = q_i + (1-q_i)\\times (1-p_i)^{n_i} \\] 一方で、0以外が得られる確率は以下のようになる。 \\[ (1-q_i)\\times _n C _0 p_i^x(1-p_i)^{n_i-x} \\; (x&gt;0) \\] 3.3 ゼロ過剰二項モデルの分析例1(GLMの場合) それでは、先ほどのデータをゼロ過剰二項モデルに当てはめよう。データが以下の式に従って得られると仮定する。モデルでは、\\(q_i\\)も年齢によって変化すると仮定する(年齢によらないと仮定することもできる)。なお、\\(num\\_inj_i \\sim ZIBinomial(p_i)\\)は怪我が確認された回数がゼロ過剰二項モデルに従って得られることを示す。 \\[ \\begin{aligned} logit(q_i) &amp;= log(\\frac{q_i}{1-q_i}) = \\beta_{10} + \\beta_{11} \\times age_i\\\\ logit(p_i) &amp;= log(\\frac{p_i}{1-p_i}) = \\beta_{20} + \\beta_{21} \\times age_i\\\\ num\\_inj_i &amp;\\sim ZIBinomial(q_i, trials_i, p_i) \\end{aligned} \\] RではglmmTMBパッケージを用いて以下のようにパラメータを推定できる。\\(q_i\\)が年齢によらないと仮定する場合は、ziformula ~ 1とする。 r_zibinom &lt;- glmmTMB(data = dat_zibinom, cbind(num_inj, sum - num_inj) ~ age, ## 年齢によらないとする場合はziformula~1 ziformula = ~age, family = &quot;binomial&quot;) モデルで推定されたパラメータは以下のようになる。 Zero-inflation model:というところにある推定結果が\\(q_i\\)に関するパラメータの推定値であり、\\(\\beta_{10}\\)と\\(\\beta_{11}\\)の推定値はそれぞれ0.574、-0.079となる。 Conditional model:というところにある推定結果が\\(p_i\\)に関するパラメータの推定値であり、\\(\\beta_{20}\\)と\\(\\beta_{21}\\)の推定値はそれぞれ-5.292、0.107となる。 summary(r_zibinom) ## Family: binomial ( logit ) ## Formula: cbind(num_inj, sum - num_inj) ~ age ## Zero inflation: ~age ## Data: dat_zibinom ## ## AIC BIC logLik deviance df.resid ## 658.3 671.5 -325.2 650.3 196 ## ## ## Conditional model: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -5.29156 0.29761 -17.780 &lt; 2e-16 *** ## age 0.10687 0.01708 6.255 3.96e-10 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Zero-inflation model: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 0.57401 0.80218 0.716 0.474 ## age -0.07934 0.05112 -1.552 0.121 推定されたたパラメータを持つゼロ過剰二項モデルの下で得られるデータをシミュレートし(num_inj_zisim)、それを実際に得られたデータと比較してみる。 ## 推定されたパラメータからデータをシミュレート q &lt;- 1/(1 +exp(-(fixef(r_zibinom)[[2]][[1]] + fixef(r_zibinom)[[2]][[2]]*dat_zibinom$age))) p &lt;- 1/(1 +exp(-(fixef(r_zibinom)[[1]][[1]] + fixef(r_zibinom)[[1]][[2]]*dat_zibinom$age))) num_inj_zisim &lt;- rbinom(N,1,1-q)*rbinom(N,dat_zibinom$sum, p) prop_inj_zisim &lt;- num_inj_zisim/dat_zibinom$sum 下の図からわかるように、ゼロ過剰二項モデルからシミュレートされたデータから算出した怪我が観察された割合(prop_inj_zisim)の分布は、さきほどよりも実際のデータにマッチしていることが分かる。 ## 実際のデータと比較 data.frame(prop_inj = dat_zibinom$num_inj/dat_zibinom$sum, prop_inj_zisim = prop_inj_zisim) %&gt;% pivot_longer(cols = 1:2) %&gt;% ggplot(aes(x = value))+ geom_histogram(aes(fill = name), position = &quot;dodge&quot;, alpha = 0.8, breaks = seq(0,0.13,0.01))+ theme_bw(base_size = 13)+ theme(aspect.ratio=0.8, axis.title.y = element_text(angle=0,vjust=0.5))+ labs(x = &quot;怪我が確認された割合&quot;, y = &quot;度\\n数&quot;) -&gt; p_zibinom_hist p_zibinom_hist これは、普通の二項分布モデルの結果(prop_inj_sim)と比較すると明白である。 data.frame(prop_inj = dat_zibinom$num_inj/dat_zibinom$sum, prop_inj_zisim = prop_inj_zisim, prop_inj_sim = prop_inj_sim) %&gt;% pivot_longer(cols = 1:3) %&gt;% mutate(name = fct_relevel(name,&quot;prop_inj&quot;,&quot;prop_inj_zisim&quot;)) %&gt;% ggplot(aes(x = value))+ geom_histogram(aes(fill = name), position = &quot;dodge&quot;, alpha = 0.8, breaks = seq(0,0.13,0.01))+ theme_bw(base_size = 13)+ theme(aspect.ratio=0.8, axis.title.y = element_text(angle=0,vjust=0.5))+ labs(x = &quot;怪我が確認された割合&quot;, y = &quot;度\\n数&quot;) 検定をしても、ゼロ過剰は検出されない。 testZeroInflation(r_zibinom) ## ## DHARMa zero-inflation test via comparison to expected zeros with ## simulation under H0 = fitted model ## ## data: simulationOutput ## ratioObsSim = 1.0061, p-value = 0.92 ## alternative hypothesis: two.sided 検定を行っても過分散は検出されない。 resid_zibinom &lt;-simulateResiduals(r_zibinom) testDispersion(resid_zibinom) ## ## DHARMa nonparametric dispersion test via sd of residuals fitted vs. ## simulated ## ## data: simulationOutput ## dispersion = 0.99165, p-value = 0.984 ## alternative hypothesis: two.sided QQplotをみても、データがモデルによく当てはまっていることが分かる。 plotQQunif(resid_zibinom) 推定されたモデルに基づく回帰曲線を描画する。 確率\\(q_i\\)で得られた0を含まないものと、含むものを両方描ける。 \\(q_i\\)で得られた0を含まない場合 fit_zibinom_a &lt;- ggpredict(r_zibinom, ## 温度は5~15で0.1刻み terms = &quot;age[5:26,by=0.1]&quot;, type =&quot;fixed&quot;) ggplot(dat_zibinom)+ geom_point(aes(x = age, y = num_inj/sum), size = 3.5, alpha = 0.6)+ ### 回帰曲線 geom_line(data = fit_zibinom_a, aes(x=x, y = predicted))+ ## 95%信頼区間 geom_ribbon(data = fit_zibinom_a, aes(x=x, y = predicted, ymin = conf.low, ymax = conf.high), alpha = 0.5)+ theme_bw(base_size = 18)+ theme(aspect.ratio= 0.8, axis.title.y = element_text(angle=0, vjust=0.5, size = 10), plot.title=element_text(size = 17))+ coord_cartesian(ylim = c(0,0.122))+ scale_y_continuous(breaks = seq(0,0.15,0.02))+ labs(title = &quot;ゼロ過剰二項モデル\\n(qによる0含まず)&quot;, y = &quot;怪\\n我\\nが\\n確\\n認\\nさ\\nれ\\nた\\n割\\n合&quot;)-&gt; p_zibinom_a \\(q_i\\)で得られた0を含む場合 fit_zibinom_b &lt;- ggpredict(r_zibinom, ## 温度は5~15で0.1刻み terms = &quot;age[5:26,by=0.1]&quot;, type =&quot;zero_inflated&quot;) ggplot(dat_zibinom)+ geom_point(aes(x = age, y = num_inj/sum), size = 3.5, alpha = 0.6)+ ### 回帰曲線 geom_line(data = fit_zibinom_b, aes(x=x, y = predicted))+ ## 95%信頼区間 geom_ribbon(data = fit_zibinom_b, aes(x=x, y = predicted, ymin = conf.low, ymax = conf.high), alpha = 0.5)+ theme_bw(base_size = 18)+ theme(aspect.ratio= 0.8, axis.title.y = element_text(angle=0, vjust=0.5, size =10), plot.title=element_text(size = 17))+ coord_cartesian(ylim = c(0,0.122))+ scale_y_continuous(breaks = seq(0,0.15,0.02))+ labs(title = &quot;ゼロ過剰二項モデル\\n(qによる0含む)&quot;, y = &quot;怪\\n我\\nが\\n確\\n認\\nさ\\nれ\\nた\\n割\\n合&quot;)-&gt; p_zibinom_b 比較のため、普通のポワソン回帰による回帰曲線も併置する。 library(patchwork) p_binom + p_zibinom_a + p_zibinom_b + plot_layout(ncol = 2) 3.4 ゼロ過剰二項モデルの分析例2(GLMMの場合) ゼロ過剰モデルはランダム効果が含まれる一般化線形モデル(GLMM)についても適用できる。先ほどと同様に ニホンザルのメスが群れ外オスから攻撃された直後に怪我が確認されるか否かを調べたとする。今度は先ほどとは異なり5年分のデータがある、すなわち同じメスについて5つのデータポイントがあるとする(dat_zibinomglmm)。なお、femaleIDはメスのIDを、sumは攻撃された回数を、num_injは攻撃の直後に怪我が確認された回数を、ageはメスの年齢を表す。 シミュレーションによって架空のデータを作成する。 ## データの作成 set.seed(1234) N &lt;- 1000 femaleID &lt;- rep(seq(1,N/5,by=1),each=5) age &lt;- rep(rnorm(N/5, 15, 3.5), each = 5) sum &lt;- rep(rpois(N/5,100), each = 5) p &lt;- exp((0.8 - 0.08*age))/(1 + exp((0.8 - 0.08*age))) r &lt;- rep(rnorm(200, mean = 0, sd = 0.8),each=5) num_inj &lt;- rep(0,N) for(i in 1:N){ num_inj[i] &lt;- rbinom(1,1,1-p[i])*rbinom(1, sum[i], exp(-5.7 + 0.15*age[i] + r[i])/(1 + exp(-5.7 + 0.15*age[i] + r[i]))) } dat_zibinom_glmm &lt;- data.frame(femaleID = as.factor(femaleID), age = age, num_inj = num_inj, sum = sum) 作成されたデータがこちら。 dat_zibinom_glmm %&gt;% datatable() サルの年齢(age)と攻撃の直後に怪我が確認された割合(num_inj/sum)をプロットしたところ、以下のようになった。年齢が高くなるほど、怪我が確認された割合が多くなるように見える。 dat_zibinom_glmm %&gt;% ggplot(aes(x = age, y = num_inj/sum))+ geom_point(size = 3.5, alpha = 0.6)+ theme_bw(base_size = 12)+ theme(aspect.ratio= 0.8, axis.title.y = element_text(angle=0, vjust=0.5, size = 10))+ coord_cartesian(ylim = c(0,0.35))+ scale_y_continuous(breaks = seq(0,0.35,0.05))+ labs(y = &quot;怪\\n我\\nが\\n確\\n認\\nさ\\nれ\\nた\\n割\\n合&quot;) 3.4.1 普通のGLMMを適用する そこで、以下のようなGLMMを考え、年齢が怪我が確認された割合に影響するかを調べる。 分布: 二項分布 リンク関数: logit関数 応答変数: 怪我が確認された割合(num_inj/sum) 説明変数: 年齢(age) ランダム切片: メスID 数式で表すと以下のようになる。ただし、\\(i\\)は各データポイントのIDを示す。例えば、\\(age_i\\)は、\\(i\\)番目の個体の年齢を表す。ただし、\\(i = 1,2,3,...,1000\\)である。 なお、\\(r_j \\sim Normal(0, \\sigma_j)\\)は\\(r_{femaleID_i}\\)が平均0、分散\\(\\sigma^2\\)の正規分布に従って得られることを示す。 \\[ \\begin{aligned} r_{femaleID_i} &amp;\\sim Normal(0, \\sigma^2) \\\\ logit(p_i) &amp;= log(\\frac{p_i}{1-p_i}) = \\beta_0 + \\beta_{1} \\times age_i + r_{femaleID_i}\\\\ num\\_inj_i &amp;\\sim Binomial(trials_i, p_i) \\end{aligned} \\] Rでは以下のように実行する。 r_binom_glmm &lt;- glmer(data = dat_zibinom_glmm, cbind(num_inj, sum-num_inj) ~ age + (1|femaleID), family = binomial(link=&quot;logit&quot;)) 結果は以下のようになり、\\(\\beta_0\\)の推定値は-7.400、\\(\\beta_1\\)の推定値は0.215、\\(\\sigma\\)の推定値は0.888である。 summary(r_binom_glmm) ## Generalized linear mixed model fit by maximum likelihood (Laplace ## Approximation) [glmerMod] ## Family: binomial ( logit ) ## Formula: cbind(num_inj, sum - num_inj) ~ age + (1 | femaleID) ## Data: dat_zibinom_glmm ## ## AIC BIC logLik deviance df.resid ## 4850.3 4865.1 -2422.2 4844.3 997 ## ## Scaled residuals: ## Min 1Q Median 3Q Max ## -4.5524 -0.9588 -0.4845 0.8565 6.3539 ## ## Random effects: ## Groups Name Variance Std.Dev. ## femaleID (Intercept) 0.7879 0.8876 ## Number of obs: 1000, groups: femaleID, 200 ## ## Fixed effects: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -7.39994 0.31328 -23.62 &lt;2e-16 *** ## age 0.21545 0.01998 10.78 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Correlation of Fixed Effects: ## (Intr) ## age -0.974 つまり、\\(r_{femaleID_i}\\)は平均0、標準偏差0.888の正規分布から得られ、怪我が確認される回数は試行数10、\\(\\frac{p_i}{1-p_i} = e^{-7.40 + 0.216 \\times age_i + r_{femaleID_i}}\\)となる二項分布から得られると推定される。 そこで、推定したパラメータを持つモデルの下で得られるデータをシミュレートし(num_inj_sim_glmm)、それを実際に得られたデータと比較してみる。 下の図からわかるように、実際に得られたデータから算出された怪我が観察された割合(prop_inj)では、推定されたモデルからシミュレートされたデータ(prop_inj_sim_glmm)より0が多い(= ゼロ過剰が生じている)。GLMの場合と同様に怪我がをしていても体毛に隠れていて気づかない場合があったなど、0が増えてしまう何らかのメカニズムがあったと推測される。 ## モデルの下で得られるデータをシミュレート p &lt;- 1/(1 +exp(-(fixef(r_binom_glmm)[[1]] + fixef(r_binom_glmm)[[2]]*dat_zibinom_glmm$age + rep(ranef(r_binom_glmm)$femaleID$`(Intercept)`,each = 5)))) num_inj_sim_glmm &lt;- rbinom(N, dat_zibinom_glmm$sum, p) prop_inj_sim_glmm &lt;- num_inj_sim_glmm/dat_zibinom_glmm$sum ## 実際のデータと比較 data.frame(prop_inj = num_inj/dat_zibinom_glmm$sum, prop_inj_sim_glmm = prop_inj_sim_glmm) %&gt;% pivot_longer(cols = 1:2) %&gt;% ggplot(aes(x = value))+ geom_histogram(aes(fill = name), position = &quot;dodge&quot;, alpha = 0.8, breaks = seq(0,0.2,by=0.01))+ theme_bw(base_size = 13)+ theme(aspect.ratio=0.8, axis.title.y = element_text(angle=0,vjust=0.5))+ labs(x = &quot;怪我が確認された割合&quot;, y = &quot;度\\n数&quot;)+ coord_cartesian(xlim = c(0,0.13))-&gt; p_binom_hist p_binom_hist 検定をすると、ゼロ過剰が検出される。 testZeroInflation(r_binom_glmm) ## ## DHARMa zero-inflation test via comparison to expected zeros with ## simulation under H0 = fitted model ## ## data: simulationOutput ## ratioObsSim = 1.6004, p-value &lt; 2.2e-16 ## alternative hypothesis: two.sided dispersion parameterを算出すると、二項分布での規定値(= 1)を越えており、過分散が生じていることが分かる。おそらくゼロ過剰が原因だろう。 resid_binom_glmm &lt;-simulateResiduals(r_binom_glmm) check_overdispersion(r_binom_glmm) ## # Overdispersion test ## ## dispersion ratio = 2.230 ## Pearson&#39;s Chi-Squared = 2223.035 ## p-value = &lt; 0.001 QQplotをみても、データがモデルによく当てはまっていないことが分かる。 plotQQunif(resid_binom_glmm) 3.4.2 ゼロ過剰二項モデル そこで、ゼロ過剰モデルを考える。 数式で表すと以下のようになる。ただし、\\(i\\)は各データポイントのIDを示す。例えば、\\(age_i\\)は、\\(i\\)番目の個体の年齢を表す。ただし、\\(i = 1,2,3,...,1000\\)である。 なお、今回は\\(q_i\\)は年齢によって変化するが、メスのIDによるばらつきはないとする(メスIDによるばらつきを仮定することもできる)。 \\[ \\begin{aligned} r_{femaleID_i} &amp;\\sim Normal(0, \\sigma^2) \\\\ logit(q_i) &amp;= log(\\frac{q_i}{1-q_i}) = \\beta_{10} + \\beta_{11} \\times age_i\\\\ logit(p_i) &amp;= log(\\frac{p_i}{1-p_i}) = \\beta_{20} + \\beta_{21} \\times age_i + r_{femaleID_i}\\\\ num\\_inj_i &amp;\\sim ZIBinomial(q_i, trials_i, p_i) \\end{aligned} \\] Rでは以下のコードで実行できる。 r_zibinom_glmm &lt;- glmmTMB(data = dat_zibinom_glmm, cbind(num_inj, sum - num_inj) ~ age + (1|femaleID), ## 年齢によらないとする場合はziformula~1, ## メスIDによるばらつきを仮定する場合はziformula ~ age + (1|femaleID) ziformula = ~age, family = &quot;binomial&quot;) モデルで推定されたパラメータは以下のようになる。 Zero-inflation model:というところにある推定結果が\\(q_i\\)に関するパラメータの推定値であり、\\(\\beta_{10}\\)と\\(\\beta_{11}\\)の推定値はそれぞれ0.547、-0.070となる。 Conditional model:というところにある推定結果が\\(p_i\\)に関するパラメータの推定値であり、\\(\\beta_{20}\\)と\\(\\beta_{21}\\)の推定値はそれぞれ-6.489、0.192となる。 summary(r_zibinom_glmm) ## Family: binomial ( logit ) ## Formula: cbind(num_inj, sum - num_inj) ~ age + (1 | femaleID) ## Zero inflation: ~age ## Data: dat_zibinom_glmm ## ## AIC BIC logLik deviance df.resid ## 3554.4 3578.9 -1772.2 3544.4 995 ## ## Random effects: ## ## Conditional model: ## Groups Name Variance Std.Dev. ## femaleID (Intercept) 0.6874 0.8291 ## Number of obs: 1000, groups: femaleID, 200 ## ## Conditional model: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -6.4889 0.3340 -19.426 &lt;2e-16 *** ## age 0.1921 0.0206 9.327 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Zero-inflation model: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 0.54743 0.41181 1.329 0.18374 ## age -0.06958 0.02534 -2.746 0.00604 ** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 推定したパラメータを持つゼロ過剰二項モデルの下で得られるデータをシミュレートし(num_inj_zisim_glmm)、それを実際に得られたデータと比較してみる。 ## 推定されたパラメータからデータをシミュレート q &lt;- 1/(1 +exp(-(fixef(r_zibinom_glmm)[[2]][[1]] + fixef(r_zibinom_glmm)[[2]][[2]]*dat_zibinom_glmm$age))) p &lt;- 1/(1 +exp(-(fixef(r_zibinom_glmm)[[1]][[1]] + fixef(r_zibinom_glmm)[[1]][[2]]*dat_zibinom_glmm$age + rep(as.vector(ranef(r_binom_glmm))$femaleID$`(Intercept)`,5)))) num_inj_zisim_glmm &lt;- rbinom(N,1,1-q)*rbinom(N,dat_zibinom_glmm$sum, p) prop_inj_zisim_glmm &lt;- num_inj_zisim_glmm/dat_zibinom_glmm$sum 下の図からわかるように、推定されたモデルからシミュレートされたデータから算出した怪我が観察された割合(prop_inj_zisim_glmm)の分布は、さきほどより実際のデータとよくマッチしていることが分かる。 ## 実際のデータと比較 data.frame(prop_inj = dat_zibinom_glmm$num_inj/dat_zibinom_glmm$sum, prop_inj_zisim_glmm = prop_inj_zisim_glmm) %&gt;% pivot_longer(cols = 1:2) %&gt;% ggplot(aes(x = value))+ geom_histogram(aes(fill = name), position = &quot;dodge&quot;, alpha = 0.8, breaks = seq(0,0.13,0.01))+ theme_bw(base_size = 13)+ theme(aspect.ratio=0.8, axis.title.y = element_text(angle=0,vjust=0.5))+ labs(x = &quot;怪我が確認された割合&quot;, y = &quot;度\\n数&quot;) -&gt; p_zibinom_glmm_hist p_zibinom_glmm_hist 検定をしても、ゼロ過剰は検出されない。 testZeroInflation(r_zibinom_glmm) ## ## DHARMa zero-inflation test via comparison to expected zeros with ## simulation under H0 = fitted model ## ## data: simulationOutput ## ratioObsSim = 0.99666, p-value = 0.952 ## alternative hypothesis: two.sided 検定を行っても過分散が検出されない。 resid_zibinom_glmm &lt;-simulateResiduals(r_zibinom_glmm) testDispersion(resid_zibinom_glmm) ## ## DHARMa nonparametric dispersion test via sd of residuals fitted vs. ## simulated ## ## data: simulationOutput ## dispersion = 0.84408, p-value = 0.608 ## alternative hypothesis: two.sided QQplotをみても、データがモデルによく当てはまっていることが分かる。 plotQQunif(resid_zibinom_glmm) 推定されたモデルに基づく回帰曲線を描画する。 確率\\(q_i\\)で得られた0を含まないものと、含むものを両方描ける。 \\(q_i\\)で得られた0を含まない場合 fit_zibinom_glmm_a &lt;- ggpredict(r_zibinom_glmm, ## 温度は5~26で0.1刻み terms = &quot;age[5:26,by=0.1]&quot;, type =&quot;fixed&quot;) ggplot(dat_zibinom_glmm)+ geom_point(aes(x = age, y = num_inj/sum), size = 3.5, alpha = 0.6)+ ### 回帰曲線 geom_line(data = fit_zibinom_glmm_a, aes(x=x, y = predicted))+ ## 95%信頼区間 geom_ribbon(data = fit_zibinom_glmm_a, aes(x=x, y = predicted, ymin = conf.low, ymax = conf.high), alpha = 0.5)+ theme_bw(base_size = 18)+ theme(aspect.ratio= 0.8, axis.title.y = element_text(angle=0, vjust=0.5, size = 10), plot.title=element_text(size = 17))+ coord_cartesian(ylim = c(0,0.35))+ scale_y_continuous(breaks = seq(0,0.35,0.05))+ labs(title = &quot;ゼロ過剰二項モデル\\n(qによる0含まず)&quot;, y = &quot;怪\\n我\\nが\\n確\\n認\\nさ\\nれ\\nた\\n割\\n合&quot;)-&gt; p_zibinom_glmm_a \\(q_i\\)で得られた0を含む場合 fit_zibinom_glmm_b &lt;- ggpredict(r_zibinom_glmm, ## 温度は5~15で0.1刻み terms = &quot;age[5:26,by=0.1]&quot;, type =&quot;zero_inflated&quot;) ggplot(dat_zibinom_glmm)+ geom_point(aes(x = age, y = num_inj/sum), size = 3.5, alpha = 0.6)+ ### 回帰曲線 geom_line(data = fit_zibinom_glmm_b, aes(x=x, y = predicted))+ ## 95%信頼区間 geom_ribbon(data = fit_zibinom_glmm_b, aes(x=x, y = predicted, ymin = conf.low, ymax = conf.high), alpha = 0.5)+ theme_bw(base_size = 18)+ theme(aspect.ratio= 0.8, axis.title.y = element_text(angle=0, vjust=0.5, size =10), plot.title=element_text(size = 17))+ coord_cartesian(ylim = c(0,0.35))+ scale_y_continuous(breaks = seq(0,0.35,0.05))+ labs(title = &quot;ゼロ過剰二項モデル\\n(qによる0含む)&quot;, y = &quot;怪\\n我\\nが\\n確\\n認\\nさ\\nれ\\nた\\n割\\n合&quot;)-&gt; p_zibinom_glmm_b library(patchwork) p_zibinom_glmm_a + p_zibinom_glmm_b + plot_layout(ncol = 2) "],["sessioninfo.html", "実行環境", " 実行環境 sessionInfo() ## R version 4.2.2 (2022-10-31 ucrt) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 10 x64 (build 22621) ## ## Matrix products: default ## ## locale: ## [1] LC_COLLATE=Japanese_Japan.utf8 LC_CTYPE=Japanese_Japan.utf8 ## [3] LC_MONETARY=Japanese_Japan.utf8 LC_NUMERIC=C ## [5] LC_TIME=Japanese_Japan.utf8 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] patchwork_1.1.2 brms_2.18.0 Rcpp_1.0.9 DHARMa_0.4.6 ## [5] statmod_1.5.0 glmmTMB_1.1.5 ggeffects_1.1.4 see_0.7.5.5 ## [9] report_0.5.7.4 parameters_0.20.3 performance_0.10.3 modelbased_0.8.6.3 ## [13] insight_0.19.1.4 effectsize_0.8.3.6 datawizard_0.7.1.1 correlation_0.8.4 ## [17] bayestestR_0.13.1 easystats_0.6.0.8 lme4_1.1-31 Matrix_1.5-1 ## [21] forcats_0.5.2 stringr_1.5.0 dplyr_1.0.10 purrr_1.0.0 ## [25] readr_2.1.3 tidyr_1.2.1 tibble_3.1.8 ggplot2_3.4.2 ## [29] tidyverse_1.3.2 ## ## loaded via a namespace (and not attached): ## [1] readxl_1.4.1 backports_1.4.1 plyr_1.8.8 ## [4] igraph_1.3.5 TMB_1.9.1 splines_4.2.2 ## [7] crosstalk_1.2.0 gap.datasets_0.0.5 inline_0.3.19 ## [10] rstantools_2.2.0 digest_0.6.31 htmltools_0.5.4 ## [13] fansi_1.0.3 magrittr_2.0.3 checkmate_2.1.0 ## [16] googlesheets4_1.0.1 tzdb_0.3.0 modelr_0.1.10 ## [19] RcppParallel_5.1.6 matrixStats_0.63.0 xts_0.12.2 ## [22] timechange_0.1.1 prettyunits_1.1.1 colorspace_2.0-3 ## [25] rvest_1.0.3 haven_2.5.1 xfun_0.36 ## [28] callr_3.7.3 crayon_1.5.2 jsonlite_1.8.4 ## [31] zoo_1.8-11 glue_1.6.2 gtable_0.3.3 ## [34] gargle_1.2.1 emmeans_1.8.3 V8_4.2.2 ## [37] distributional_0.3.1 pkgbuild_1.4.0 rstan_2.26.13 ## [40] abind_1.4-5 scales_1.2.1 mvtnorm_1.1-3 ## [43] DBI_1.1.3 miniUI_0.1.1.1 xtable_1.8-4 ## [46] StanHeaders_2.26.13 stats4_4.2.2 DT_0.27 ## [49] htmlwidgets_1.6.1 httr_1.4.4 threejs_0.3.3 ## [52] posterior_1.3.1 ellipsis_0.3.2 pkgconfig_2.0.3 ## [55] loo_2.5.1 farver_2.1.1 sass_0.4.5 ## [58] dbplyr_2.2.1 utf8_1.2.2 labeling_0.4.2 ## [61] tidyselect_1.2.0 rlang_1.1.1 reshape2_1.4.4 ## [64] later_1.3.0 munsell_0.5.0 cellranger_1.1.0 ## [67] tools_4.2.2 cachem_1.0.6 cli_3.6.0 ## [70] generics_0.1.3 broom_1.0.2 evaluate_0.20 ## [73] fastmap_1.1.0 yaml_2.3.7 processx_3.8.0 ## [76] knitr_1.42 fs_1.5.2 nlme_3.1-160 ## [79] mime_0.12 xml2_1.3.3 gap_1.4-2 ## [82] compiler_4.2.2 bayesplot_1.10.0 shinythemes_1.2.0 ## [85] rstudioapi_0.14 png_0.1-8 curl_4.3.3 ## [88] reprex_2.0.2 bslib_0.4.2 stringi_1.7.8 ## [91] highr_0.10 ps_1.7.2 Brobdingnag_1.2-9 ## [94] lattice_0.20-45 nloptr_2.0.3 markdown_1.4 ## [97] shinyjs_2.1.0 tensorA_0.36.2 vctrs_0.5.1 ## [100] pillar_1.9.0 lifecycle_1.0.3 jquerylib_0.1.4 ## [103] bridgesampling_1.1-2 estimability_1.4.1 httpuv_1.6.7 ## [106] R6_2.5.1 bookdown_0.31 promises_1.2.0.1 ## [109] gridExtra_2.3 codetools_0.2-18 boot_1.3-28 ## [112] colourpicker_1.2.0 MASS_7.3-58.1 gtools_3.9.4 ## [115] assertthat_0.2.1 withr_2.5.0 shinystan_2.6.0 ## [118] parallel_4.2.2 hms_1.1.2 grid_4.2.2 ## [121] coda_0.19-4 minqa_1.2.5 rmarkdown_2.20 ## [124] googledrive_2.0.0 numDeriv_2016.8-1.1 shiny_1.7.4 ## [127] lubridate_1.9.0 base64enc_0.1-3 dygraphs_1.1.1.6 References Chang, W. (2018). R graphics cookbook: Practical recipes for visualizing data. “O’Reilly Media, Inc.” Fox, G., &amp; Sosa, V. (2015). Mixture models for overdispersed data. In Ecological statictics: Contemporary theory and application (pp. 284–308). Oxford University Press. Harrison, X. A., Donaldson, L., Correa-Cano, M. E., Evans, J., Fisher, D. N., Goodwin, C. E. D., Robinson, B. S., Hodgson, D. J., &amp; Inger, R. (2018). A brief introduction to mixed effects modelling and multi-model inference in ecology. PeerJ, 2018(5). Wickham, H., &amp; Grolemund, G. (2016). R for data science: Import, tidy, transform, visualize, and model data. “O’Reilly Media, Inc.” 松村優哉., 湯谷啓明., 紀ノ定保礼., &amp; 前田和. (2021). RユーザのためのRstudio[実践]入門 tidyverseによるモダンな分析フローの世界 改訂2版. 技術評論社. 松浦健太郎. (2016). StanとRでベイズ統計モデリング. 共立出版. 粕谷英一. (2012). 一般化線形モデル. 共立出版. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
